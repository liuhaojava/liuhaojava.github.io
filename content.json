[{"title":"Java-类加载机制","date":"2019-02-28T06:43:57.000Z","path":"Java总结/Java-类加载机制/","text":"JVM将类加载过程分为三个步骤：装载（Load），链接（Link）和初始化(Initialize)。链接又分为三个步骤，如下图所示: 装载：通过类加载器，查找并加载类的二进制数据 链接： 验证：确保被加载类的正确性；检查class文件是否符合JVM字节码格式的，正常情况由编译器生成的class文件肯定符合，如果不是，那需要验证通过才能下一步，安全考虑 准备：为类的静态变量分配内存，并将其初始化为默认值；如private static int a = 10在准备阶段即a=0，然后解析，再到初始化的时候才a=10 解析：把类中的符号引用转换为直接引用 初始化：为类的静态变量赋予正确的初始值，及创建对象 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个这个类的java.lang.Class对象，用来封装类在方法区类的对象 使用对象 卸载 类加载器 启动类加载器(Bootstrap ClassLoader)：负责加载 JAVA_HOME\\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类 扩展类加载器(Extension ClassLoader)：负责加载 JAVA_HOME\\lib\\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类库 应用程序类加载器(Application ClassLoader)：负责加载用户路径（classpath）上的类库 自定义类加载器 JDK中的ClassLoader通过上面可以看出findClass()的实现，直接抛出一个异常，并且方法是protected，很明显这是留给我们开发者自己去实现的，我们可以通过重写findClass方法来实现我们自己的类加载器。Springboot通过@EnableAutoConfiguration注解，会根据META-INF/spring.factories文件自动配置，通过@Configuration代理原来的xml配置类，通过@ComponentScan配置类扫描路径，反射生成ioc容器","tags":[{"name":"Java总结","slug":"Java总结","permalink":"http://www.bestliuhao.club/tags/Java总结/"}]},{"title":"Java-数据类型","date":"2019-02-28T06:25:26.000Z","path":"Java总结/Java-数据类型/","text":"类型 位数 字节数 取值范围 byte 8 1 -2^7 ~ 2^7-1 short 16 2 -2^15 ~ 2^15-1 int 32 4 -2^31 ~ 2^31-1 long 64 8 -2^63 ~ 2^63-1 float 32 4 2^-149 ~ 2^128-1 double 64 8 2^-1074 ~ 2^1024-1 char 16 2 0 ~ 2^16-1 boolean: 没有固定大小根据虚拟机定义 Bit(位)、byte、字节、汉字的关系 1 bit = 1 二进制数据 1 byte = 8 bit 1 字母 = 1 byte = 8 bit 1 汉字 = 2 byte = 16 bit bit：位 一个二进制数据0或1，是1bit； byte：字节存储空间的基本计量单位，如：MySQL中定义 VARCHAR(45) 即是指 45个字节；1 byte = 8 bit 一个英文字符占一个字节； 1 字母 = 1 byte = 8 bit 一个汉字占2个字节； 1 汉字 = 2 byte = 16 bit 标点符号 汉字输入状态下，默认为全角输入方式； 英文输入状态下，默认为半角输入方式； 全角输入方式下，标点符号占2字节； 半角输入方式下，标点符号占1字节；故：汉字输入状态下的字符，占2个字节 (但不排除，自己更改了默认设置)； 英文输入状态下的字符，占1个字节 (但不排除，自己更改了默认设置)；","tags":[{"name":"Java总结","slug":"Java总结","permalink":"http://www.bestliuhao.club/tags/Java总结/"}]},{"title":"Java Bean Validation完成后端数据校验","date":"2019-01-24T08:04:09.000Z","path":"Java/Java-Bean-Validation完成后端数据校验/","text":"前言 数据的校验是交互式网站一个不可或缺的功能，前端的js校验可以涵盖大部分的校验职责，如用户名唯一性，生日格式，邮箱格式校验等等常用的校验。但是为了避免用户绕过浏览器，使用http工具直接向后端请求一些违法数据，服务端的数据校验也是必要的，可以防止脏数据落到数据库中，如果数据库中出现一个非法的邮箱格式，也会让运维人员头疼不已。我在之前保险产品研发过程中，系统对数据校验要求比较严格且追求可变性及效率，曾使用drools作为规则引擎，兼任了校验的功能。而在一般的应用，可以使用本文将要介绍的validation来对数据进行校验。 JSR303/JSR-349 简述JSR303/JSR-349，Hibernate Validation，Spring Validation之间的关系。JSR303是一项标准,JSR-349是其的升级版本，添加了一些新特性，他们规定一些校验规范即校验注解，如@Null，@NotNull，@Pattern，他们位于javax.validation.constraints包下，只提供规范不提供实现。而hibernate validation是对这个规范的实践（不要将hibernate和数据库orm框架联系在一起），他提供了相应的实现，并增加了一些其他校验注解，如@Email，@Length，@Range等等，他们位于org.hibernate.validator.constraints包下。而万能的Spring为了给开发者提供便捷，对Hibernate Validation进行了二次封装，显示校验validated bean时，你可以使用Spring Validation或者Hibernate Validation，而Springvalidation另一个特性，便是其在SpringMVC模块中添加了自动校验，并将校验信息封装进了特定的类中。这无疑便捷了我们的web开发。本文主要介绍在SpringMVC中自动校验的机制。注解如下： JSR提供的校验注解： 注解 注释 @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max=, min=) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式 Hibernate Validator提供的校验注解： 注解 注释 @NotBlank(message =) 验证字符串非null，且长度必须大于0 @Email 被注释的元素必须是电子邮箱地址 @Length(min=,max=) 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range(min=,max=,message=) 被注释的元素必须在合适的范围内 代码实现添加JAR包依赖123456&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.7.Final&lt;/version&gt; &lt;!--&lt;classifier&gt;sources&lt;/classifier&gt;--&gt;&lt;/dependency&gt; 简单校验1.在pojo中指定校验规则12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.Getter;import lombok.Setter;import org.hibernate.validator.constraints.Length;import org.springframework.format.annotation.DateTimeFormat;import javax.validation.constraints.*;import java.util.Date;@ApiModel@Getter@Setterpublic class UserInfo &#123; @ApiModelProperty(value = \"姓名\") @NotEmpty(message = \"姓名不能为空！\") @Max(value = 5, message = \"姓名长度不能超过5！\") private String name; @Length(max = 10, message = \"昵称长度不能超过10！\") @ApiModelProperty(value = \"昵称\") private String nickname; @Pattern(regexp = \"[男|女]\", message = \"性别只能在男或女中选择！\") @ApiModelProperty(value = \"性别\") private String sex; @Digits(integer = 18, fraction = 28, message = \"年龄必须在18-28之间！\") @ApiModelProperty(value = \"年龄\") private Integer age; @Past(message = \"生日必须在过去的时间里！\") @ApiModelProperty(value = \"生日\") @DateTimeFormat(pattern = \"yyyy-MM-dd\") private Date birthday; @ApiModelProperty(value = \"籍贯\") private String nativePlace; @Pattern(regexp = \"^0\\\\d&#123;2,3&#125;-\\\\d&#123;7,8&#125;$\", message = \"固定电话格式不正确！\") @ApiModelProperty(value = \"固定电话\") private String telephone; @Pattern(regexp = \"^1\\\\d&#123;10&#125;$\", message = \"移动电话格式不正确！\") @ApiModelProperty(value = \"移动电话\") private String phone; @Email(message = \"邮箱格式不正确！\") @ApiModelProperty(value = \"邮箱\") private String email; @Override public String toString() &#123; return \"UserInfo&#123;\" + \"name='\" + name + '\\'' + \", nickname='\" + nickname + '\\'' + \", sex='\" + sex + '\\'' + \", age=\" + age + \", birthday=\" + birthday + \", nativePlace='\" + nativePlace + '\\'' + \", telephone='\" + telephone + '\\'' + \", phone='\" + phone + '\\'' + \", email='\" + email + '\\'' + '&#125;'; &#125;&#125; 2.controller中对其校验绑定进行使用12345678910111213141516171819202122232425262728293031import io.swagger.annotations.Api;import org.springframework.stereotype.Controller;import org.springframework.validation.BindingResult;import org.springframework.validation.FieldError;import org.springframework.validation.annotation.Validated;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import qgs.csmp.zzz.UserInfo;import qgs.framework.core.annotation.AuthPassport;import qgs.framework.core.common.BaseController;@Api(tags = \"validation校验demo\")@Controller@RequestMapping(\"/validation\")public class DemoController extends BaseController &#123; @AuthPassport(value = false) @ResponseBody @RequestMapping(method = RequestMethod.GET) public String save(@Validated UserInfo userInfo, BindingResult bindingResult) &#123; if (bindingResult.hasErrors()) &#123; StringBuilder sb = new StringBuilder(); for (FieldError fieldError : bindingResult.getFieldErrors()) &#123; sb.append(fieldError.getDefaultMessage()).append(\",\\n\"); &#125; return sb.toString(); &#125; return \"success\"; &#125;&#125; 注： 1、@Validated作用就是将pojo内的注解数据校验规则(@NotNull等)生效，如果没有该注解的声明，pojo内有注解数据校验规则也不会生效2、BindingResult对象用来获取校验失败的信息(@NotNull中的message)，与@Validated注解必须配对使用，一前一后 对BindingResult统一异常拦截 统一异常拦截后，不必每次都对controller接口增加参数BindingResult。代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.validation.BindingResult;import org.springframework.web.bind.MethodArgumentNotValidException;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import qgs.framework.util.utilty.StringUtil;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.validation.ConstraintViolation;import javax.validation.ConstraintViolationException;import java.io.IOException;import java.io.PrintWriter;import java.util.Set;@ControllerAdvicepublic class ExceptionLogInterceptor &#123; @SuppressWarnings(\"rawtypes\") @ResponseBody @ExceptionHandler(Exception.class) public void resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception e) &#123; Logger logger = LoggerFactory.getLogger(getClass()); StringBuilder errorMsg = new StringBuilder(); StringBuilder errorLog = new StringBuilder(); if (e instanceof BindingResult || e instanceof MethodArgumentNotValidException || e instanceof ConstraintViolationException) &#123; BindingResult bindingResult = null; if (e instanceof BindingResult) &#123; bindingResult = (BindingResult) e; &#125; //实体类中包含其他实体 if (e instanceof MethodArgumentNotValidException) &#123; MethodArgumentNotValidException validException = (MethodArgumentNotValidException) e; bindingResult = validException.getBindingResult(); &#125; if (bindingResult != null &amp;&amp; bindingResult.getAllErrors() != null &amp;&amp; !bindingResult.getAllErrors().isEmpty()) &#123; errorMsg = new StringBuilder(bindingResult.getAllErrors().get(0).getDefaultMessage()); &#125; if (e instanceof ConstraintViolationException) &#123; Set&lt;ConstraintViolation&lt;?&gt;&gt; violations = ((ConstraintViolationException) e).getConstraintViolations(); for (ConstraintViolation&lt;?&gt; violation : violations) &#123; errorMsg.append(violation.getMessage()).append(\", \"); &#125; &#125; &#125; else &#123; errorMsg.append(StringUtil.isNullOrEmpty(e.getMessage()) ? e.toString() : e.getMessage()); errorLog.append(StringUtil.isNullOrEmpty(e.getMessage()) ? e.toString() : e.getMessage()); errorLog.append(\"\\r\\n\"); for (StackTraceElement traceElement : e.getStackTrace()) &#123; errorLog.append(traceElement.toString()); errorLog.append(\"\\r\\n\"); &#125; &#125; logger.error(errorLog.toString()); try &#123; response.setStatus(500); response.setContentType(\"application/json; charset=utf-8\"); PrintWriter out = response.getWriter(); out.append(\"&#123;\\\"msg\\\":\\\"\").append(errorMsg.toString()).append(\"\\\"&#125;\"); out.close(); &#125; catch (IOException ignored) &#123; &#125; &#125;&#125; 注： 这里只对一处不符合规则的错误信息输出 此时，controller代码可更改为：12345678public class DemoController extends BaseController &#123; @AuthPassport(value = false) @ResponseBody @RequestMapping(method = RequestMethod.GET) public String save(@Validated UserInfo userInfo) &#123; return \"success\"; &#125;&#125; 或者12345678public class DemoController extends BaseController &#123; @AuthPassport(value = false) @ResponseBody @RequestMapping(method = RequestMethod.GET) public String save(@Valid UserInfo userInfo) &#123; return \"success\"; &#125;&#125; @Validated或者@Valid均可 分组校验1.什么是分组校验？ 校验规则是在pojo制定的，而同一个pojo可以被多个Controller使用，此时会有问题，即：不同的Controller方法对同一个pojo进行校验，此时这些校验信息是共享在这不同的Controller方法中，但是实际上每个Controller方法可能需要不同的校验，在这种情况下，就需要使用分组校验来解决这种问题，通俗的讲，一个pojo中有很多属性，controller中的方法1可能只需要校验pojo中的属性1，controller中的方法2只需要校验pojo中的属性2，但是pojo中的校验注解有很多，怎样才能使方法1只校验属性1，方法二只校验属性2呢？就需要用分组校验来解决了。 2.定义分组 1.定义空的接口12public interface ValidationGroup1 &#123;&#125; 12public interface ValidationGroup2 &#123;&#125; 2.修改pojo，注解增加参数groups123456789101112131415161718192021222324252627282930313233343536373839404142434445public class UserInfo &#123; @ApiModelProperty(value = \"姓名\") @NotEmpty(message = \"姓名不能为空！\", groups = ValidationGroup1.class) @Max(value = 5, message = \"姓名长度不能超过5！\") private String name; @Length(max = 10, message = \"昵称长度不能超过10！\", groups = ValidationGroup2.class) @ApiModelProperty(value = \"昵称\") private String nickname; @Pattern(regexp = \"[男|女]\", message = \"性别只能在男或女中选择！\") @ApiModelProperty(value = \"性别\") private String sex; @Digits(integer = 18, fraction = 28, message = \"年龄必须在18-28之间！\") @ApiModelProperty(value = \"年龄\") private Integer age; @Past(message = \"生日必须在过去的时间里！\") @ApiModelProperty(value = \"生日\") @DateTimeFormat(pattern = \"yyyy-MM-dd\") private Date birthday; @ApiModelProperty(value = \"籍贯\") private String nativePlace; @Pattern(regexp = \"^0\\\\d&#123;2,3&#125;-\\\\d&#123;7,8&#125;$\", message = \"固定电话格式不正确！\") @ApiModelProperty(value = \"固定电话\") private String telephone; @Pattern(regexp = \"^1\\\\d&#123;10&#125;$\", message = \"移动电话格式不正确！\") @ApiModelProperty(value = \"移动电话\") private String phone; @Email(message = \"邮箱格式不正确！\") @ApiModelProperty(value = \"邮箱\") private String email; @Override public String toString() &#123; return \"UserInfo&#123;\" + \"name='\" + name + '\\'' + \", nickname='\" + nickname + '\\'' + \", sex='\" + sex + '\\'' + \", age=\" + age + \", birthday=\" + birthday + \", nativePlace='\" + nativePlace + '\\'' + \", telephone='\" + telephone + '\\'' + \", phone='\" + phone + '\\'' + \", email='\" + email + '\\'' + '&#125;'; &#125;&#125; 2.修改controller12345678public class DemoController extends BaseController &#123; @AuthPassport(value = false) @ResponseBody @RequestMapping(method = RequestMethod.GET) public String save(@Validated(value = &#123;ValidationGroup1.class&#125;) UserInfo userInfo) &#123; return \"success\"; &#125;&#125; 注： 此时只能使用@Validated注解如上，只校验pojo中groups为ValidationGroup1的属性，如name有两处校验，只会校验是否为空而不会校验长度是否大于5 自定义注解校验 业务需求总是比框架提供的这些简单校验要复杂的多，我们可以自定义校验来满足我们的需求。自定义Spring Validation非常简单，主要分为两步。 1.自定义校验注解我们尝试添加一个“字符串不能包含空格”的限制。123456789101112131415161718192021222324252627282930import javax.validation.Constraint;import javax.validation.Payload;import java.lang.annotation.Documented;import java.lang.annotation.Retention;import java.lang.annotation.Target;import static java.lang.annotation.ElementType.*;import static java.lang.annotation.RetentionPolicy.RUNTIME;@Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER&#125;)@Retention(RUNTIME)@Documented@Constraint(validatedBy = &#123;CannotHaveBlankValidator.class&#125;)public @interface CannotHaveBlank &#123; String message() default \"不能包含空格\"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; //指定多个时使用 @Target(&#123;FIELD, METHOD, PARAMETER, ANNOTATION_TYPE&#125;) @Retention(RUNTIME) @Documented @interface List &#123; CannotHaveBlank[] value(); &#125;&#125; 2 编写校验类12345678910111213141516171819202122232425import javax.validation.ConstraintValidator;import javax.validation.ConstraintValidatorContext;public class CannotHaveBlankValidator implements ConstraintValidator&lt;CannotHaveBlank, String&gt; &#123; @Override public void initialize(CannotHaveBlank constraintAnnotation) &#123; &#125; @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; //null时不进行校验 if (value != null &amp;&amp; value.contains(\" \")) &#123; //获取默认提示信息 String defaultConstraintMessageTemplate = context.getDefaultConstraintMessageTemplate(); System.out.println(\"default message :\" + defaultConstraintMessageTemplate); //禁用默认提示信息 context.disableDefaultConstraintViolation(); //设置提示语 context.buildConstraintViolationWithTemplate(\"can not contains blank\").addConstraintViolation(); return false; &#125; return true; &#125;&#125; 注: 所有的验证者都需要实现ConstraintValidator接口，它的接口包含一个初始化事件方法，和一个判断是否合法的方法。ConstraintValidatorContext 这个上下文包含了认证中所有的信息，我们可以利用这个上下文实现获取默认错误提示信息，禁用错误提示信息，改写错误提示信息等操作。 基于方法校验(controller层方法中单个参数校验) 12345678910111213@Api(tags = \"validation校验demo\")@Controller@RequestMapping(\"/validation\")@Validatedpublic class DemoController extends BaseController &#123; @AuthPassport(value = false) @ResponseBody @RequestMapping(method = RequestMethod.GET) public String save(@NotNull(message = \"不能为空\") Integer id) &#123; return \"success\"; &#125;&#125; 1.为类添加@Validated注解2.校验方法的返回值和入参","tags":[{"name":"Validation完成后端数据校验","slug":"Validation完成后端数据校验","permalink":"http://www.bestliuhao.club/tags/Validation完成后端数据校验/"}]},{"title":"mysql分页列表使用LEFT JOIN时的优化方法","date":"2019-01-21T02:13:44.887Z","path":"数据库/mysql分页列表使用LEFT JOIN时的优化方法/","text":"mysql分页列表使用LEFT JOIN时的优化方法分页列表查询一般格式 取分页数据 1234567SELECT *FROM table1 t1LEFT JOIN table2 t2 ON t2.id = t1.idLEFT JOIN table3 t3 ON t3.id = t1.idLEFT JOIN table4 t4 ON t4.id = t1.idWHERE t1.id = 1 AND t2. ...LIMIT 0,30 取总数 123456SELECT COUNT(0)FROM table1 t1LEFT JOIN table2 t2 ON t2.id = t1.idLEFT JOIN table3 t3 ON t3.id = t1.idLEFT JOIN table4 t4 ON t4.id = t1.idWHERE t1.id = 1 AND t2. ... 缺点 LEFT JOIN消耗性能 全部LEFT JOIN后再取分页 取总数时候不必要的LEFT JOIN影响性能 优化 WHERE 条件语句用不到的LEFT JOIN的表，放到取分页后面 取总数时候不必要的LEFT JOIN不要 取分页数据 12345678910SELECT *FROM ( SELECT * FROM table1 t1 LEFT JOIN table2 t2 ON t2.id = t1.id LEFT JOIN table3 t3 ON t3.id = t1.id WHERE t1.id = 1 AND t2. ... LIMIT 0,30 )tLEFT JOIN table4 t4 ON t4.id = t1.id 取总数 12345SELECT COUNT(0)FROM table1 t1LEFT JOIN table2 t2 ON t2.id = t1.idLEFT JOIN table2 t3 ON t3.id = t1.idWHERE t1.id = 1 AND t2. ... 具体实际应用网站分页列表优化前 数据量：9741 每页显示30条数据 平均每页刷新耗时：1100ms 列表数据12345678910111213141516171819202122232425262728293031SELECT w.*, d.`name` AS deptName, IFNULL(de.`name`,&apos;&apos;) AS superviseName, CASE WHEN w.school_id IS NULL THEN d.`name` ELSE s.name END AS schoolName FROM website w LEFT JOIN sys_dept d ON d.id = w.dept_id LEFT JOIN sys_dept de ON de.id = w.supervise_id LEFT JOIN sys_dept scan ON scan.id = w.scan_id LEFT JOIN sys_dept verify ON verify.id = w.verify_id LEFT JOIN sys_dept_info i ON i.dept_id = w.dept_id LEFT JOIN dictionary_item item ON i.area_id = item.id LEFT JOIN school s ON s.id = w.school_id WHERE w.is_del = 0 &lt;if test=&quot;deptId != null and deptId != &apos;&apos;&quot;&gt; AND d.id = #&#123;deptId&#125; &lt;/if&gt; &lt;if test=&quot;name != null and name != &apos;&apos;&quot;&gt; AND (UPPER(w.name) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;name&#125;,&apos;%&apos;))) OR UPPER(w.py) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;name&#125;,&apos;%&apos;)))) &lt;/if&gt; &lt;if test=&quot;url != null and url != &apos;&apos;&quot;&gt; AND UPPER(w.url) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;url&#125;,&apos;%&apos;))) &lt;/if&gt; &lt;if test=&quot;linkman != null and linkman != &apos;&apos;&quot;&gt; AND UPPER(w.contact_name) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;linkman&#125;,&apos;%&apos;))) &lt;/if&gt; ORDER BY w.create_date DESC &lt;if test=&quot;pageSize != null &quot;&gt; LIMIT #&#123;offset&#125;, #&#123;pageSize&#125; &lt;/if&gt; 网站数量123456789101112131415161718192021222324SELECT COUNT(0) FROM website w LEFT JOIN sys_dept d ON d.id = w.dept_id LEFT JOIN sys_dept de ON de.id = w.supervise_id LEFT JOIN sys_dept scan ON scan.id = w.scan_id LEFT JOIN sys_dept verify ON verify.id = w.verify_id LEFT JOIN sys_dept_info i ON i.dept_id = w.dept_id LEFT JOIN dictionary_item item ON i.area_id = item.id LEFT JOIN school s ON s.id = w.school_id WHERE w.is_del = 0 &lt;if test=&quot;deptId != null and deptId != &apos;&apos;&quot;&gt; AND d.id = #&#123;deptId&#125; &lt;/if&gt; &lt;if test=&quot;name != null and name != &apos;&apos;&quot;&gt; AND (UPPER(w.name) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;name&#125;,&apos;%&apos;))) OR UPPER(w.py) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;name&#125;,&apos;%&apos;)))) &lt;/if&gt; &lt;if test=&quot;url != null and url != &apos;&apos;&quot;&gt; AND UPPER(w.url) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;url&#125;,&apos;%&apos;))) &lt;/if&gt; &lt;if test=&quot;linkman != null and linkman != &apos;&apos;&quot;&gt; AND UPPER(w.contact_name) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;linkman&#125;,&apos;%&apos;))) &lt;/if&gt; 优化 数据量：9741 每页显示300条数据 平均每页刷新耗时：120ms 每页显示30条数据 平均每页刷新耗时：50ms 列表数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849SELECT t.*, item.name AS areaName, IFNULL(scan.`name`, &apos;&apos;) AS scanName, IFNULL(verify.`name`, &apos;&apos;) AS verifyName, de.`name` AS superviseName FROM ( SELECT w.id, w.name, w.url, w.dept_id, w.scan_id, w.supervise_id, w.verify_id, CASE WHEN w.school_id IS NULL THEN d.`name` ELSE s.name END AS schoolName, d.`name` AS deptName FROM website w LEFT JOIN sys_dept d ON d.id = w.dept_id LEFT JOIN school s ON s.id = w.school_id WHERE w.is_del = 0 &lt;if test=&quot;deptId != null and deptId != &apos;&apos;&quot;&gt; AND d.id = #&#123;deptId&#125; &lt;/if&gt; &lt;if test=&quot;deptName != null and deptName != &apos;&apos;&quot;&gt; AND (UPPER(d.name) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;deptName&#125;,&apos;%&apos;))) OR UPPER(d.py) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;deptName&#125;,&apos;%&apos;))) OR UPPER(s.name) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;deptName&#125;,&apos;%&apos;)))) &lt;/if&gt; &lt;if test=&quot;name != null and name != &apos;&apos;&quot;&gt; AND (UPPER(w.name) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;name&#125;,&apos;%&apos;))) OR UPPER(w.py) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;name&#125;,&apos;%&apos;)))) &lt;/if&gt; &lt;if test=&quot;url != null and url != &apos;&apos;&quot;&gt; AND UPPER(w.url) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;url&#125;,&apos;%&apos;))) &lt;/if&gt; &lt;if test=&quot;linkman != null and linkman != &apos;&apos;&quot;&gt; AND UPPER(w.contact_name) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;linkman&#125;,&apos;%&apos;))) &lt;/if&gt; ORDER BY w.create_date DESC &lt;if test=&quot;pageSize != null &quot;&gt; LIMIT #&#123;offset&#125;, #&#123;pageSize&#125; &lt;/if&gt; ) t LEFT JOIN sys_dept_info i ON i.dept_id = t.dept_id LEFT JOIN dictionary_item item ON i.area_id = item.id LEFT JOIN sys_dept de ON de.id = t.supervise_id LEFT JOIN sys_dept scan ON scan.id = t.scan_id LEFT JOIN sys_dept verify ON verify.id = t.verify_id 网站数量12345678910111213141516171819202122232425262728293031323334353637383940SELECT COUNT(0) FROM ( SELECT w.id, w.name, w.url, w.dept_id, w.scan_id, w.supervise_id, w.verify_id, CASE WHEN w.school_id IS NULL THEN d.`name` ELSE s.name END AS schoolName, d.`name` AS deptName FROM website w LEFT JOIN sys_dept d ON d.id = w.dept_id LEFT JOIN school s ON s.id = w.school_id WHERE w.is_del = 0 &lt;if test=&quot;deptId != null and deptId != &apos;&apos;&quot;&gt; AND d.id = #&#123;deptId&#125; &lt;/if&gt; &lt;if test=&quot;deptName != null and deptName != &apos;&apos;&quot;&gt; AND (UPPER(d.name) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;deptName&#125;,&apos;%&apos;))) OR UPPER(d.py) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;deptName&#125;,&apos;%&apos;))) OR UPPER(s.name) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;deptName&#125;,&apos;%&apos;)))) &lt;/if&gt; &lt;if test=&quot;name != null and name != &apos;&apos;&quot;&gt; AND (UPPER(w.name) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;name&#125;,&apos;%&apos;))) OR UPPER(w.py) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;name&#125;,&apos;%&apos;)))) &lt;/if&gt; &lt;if test=&quot;url != null and url != &apos;&apos;&quot;&gt; AND UPPER(w.url) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;url&#125;,&apos;%&apos;))) &lt;/if&gt; &lt;if test=&quot;linkman != null and linkman != &apos;&apos;&quot;&gt; AND UPPER(w.contact_name) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;linkman&#125;,&apos;%&apos;))) &lt;/if&gt; ORDER BY w.create_date DESC &lt;if test=&quot;pageSize != null &quot;&gt; LIMIT #&#123;offset&#125;, #&#123;pageSize&#125; &lt;/if&gt; ) t","tags":[{"name":"mysql分页列表优化","slug":"mysql分页列表优化","permalink":"http://www.bestliuhao.club/tags/mysql分页列表优化/"}]},{"title":"Hello World","date":"2019-01-18T02:45:19.128Z","path":"uncategorized/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]