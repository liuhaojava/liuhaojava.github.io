[{"title":"springboot集成swagger2遇到的问题","date":"2019-05-13T08:41:28.000Z","path":"问题及解决/springboot集成swagger2遇到的问题/","text":"springboot项目集成swagger2的问题项目是从SSM项目整合过来的，swagger原本就有的，没有问题。整合到springboot项目时候，http://ip:port/swagger-ui.html会报错。swagger配置如下： @Configuration @EnableSwagger2 public class SwaggerConfig { @Bean public Docket docketBean() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo(\"教育厅一级平台\")) .select() .apis(RequestHandlerSelectors.basePackage(\"qgs.education.platform.province.controller\")) //开启swagger .paths(PathSelectors.any()) //禁用swagger // .paths(PathSelectors.none()) .build() .globalOperationParameters(setHeaderToken()); } private ApiInfo apiInfo(String title) { return new ApiInfoBuilder() .title(title) .build(); } private Docket docket(String groupName, String title, String pathRegex) { return new Docket(DocumentationType.SWAGGER_2) .groupName(groupName).apiInfo(apiInfo(title)) .ignoredParameterTypes(ApiIgnore.class) .select() .apis(RequestHandlerSelectors.any()) .paths(regex(pathRegex)) .build() .globalOperationParameters(setHeaderToken()); } private List&lt;Parameter&gt; setHeaderToken() { ParameterBuilder tokenPar = new ParameterBuilder(); List&lt;Parameter&gt; pars = new ArrayList&lt;&gt;(); tokenPar.name(\"Token\").description(\"令牌\").modelRef(new ModelRef(\"string\")).parameterType(\"header\").required(false).build(); pars.add(tokenPar.build()); return pars; } } 拦截器配置如下： @Configuration public class InterceptorConfig implements WebMvcConfigurer { @Autowired private ControllerInterceptor controllerInterceptor; @Autowired private AuthBusinessInterceptor authBusinessInterceptor; @Autowired private AuthPlatformInterceptor authPlatformInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(controllerInterceptor); registry.addInterceptor(authBusinessInterceptor); registry.addInterceptor(authPlatformInterceptor) .addPathPatterns(\"/**\"); } @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\"/**\").addResourceLocations(\"/\"); registry.addResourceHandler(\"/**\") .addResourceLocations(\"classpath:/static/\"); registry.addResourceHandler(\"swagger-ui.html\") .addResourceLocations(\"classpath:/META-INF/resources/\"); registry.addResourceHandler(\"/webjars/**\") .addResourceLocations(\"classpath:/META-INF/resources/webjars/\"); } /** * 配置servlet处理 */ @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) { configurer.enable(); } } 如上配置访问http://ip:port/swagger-ui.html会报错访问http://ip:port/v2/api-docs正常猜想应该是没有找到静态资源的问题，但是拦截器配置那里是加了的 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\"/**\").addResourceLocations(\"/\"); registry.addResourceHandler(\"/**\") .addResourceLocations(\"classpath:/static/\"); registry.addResourceHandler(\"swagger-ui.html\") .addResourceLocations(\"classpath:/META-INF/resources/\"); registry.addResourceHandler(\"/webjars/**\") .addResourceLocations(\"classpath:/META-INF/resources/webjars/\"); } 以上代码不起作用。网上找了好久，偶然看到一个swagger配置继承WebMvcConfigurationSupport，试了一下，是可以的。修改后的配置：swagger配置修改后如下： @Configuration @EnableSwagger2 public class SwaggerConfig extends WebMvcConfigurationSupport { @Bean public Docket docketBean() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo(\"教育厅一级平台\")) .select() .apis(RequestHandlerSelectors.basePackage(\"qgs.education.platform.province.controller\")) //开启swagger .paths(PathSelectors.any()) //禁用swagger // .paths(PathSelectors.none()) .build() .globalOperationParameters(setHeaderToken()); } private ApiInfo apiInfo(String title) { return new ApiInfoBuilder() .title(title) .build(); } private Docket docket(String groupName, String title, String pathRegex) { return new Docket(DocumentationType.SWAGGER_2) .groupName(groupName).apiInfo(apiInfo(title)) .ignoredParameterTypes(ApiIgnore.class) .select() .apis(RequestHandlerSelectors.any()) .paths(regex(pathRegex)) .build() .globalOperationParameters(setHeaderToken()); } private List&lt;Parameter&gt; setHeaderToken() { ParameterBuilder tokenPar = new ParameterBuilder(); List&lt;Parameter&gt; pars = new ArrayList&lt;&gt;(); tokenPar.name(\"Token\").description(\"令牌\").modelRef(new ModelRef(\"string\")).parameterType(\"header\").required(false).build(); pars.add(tokenPar.build()); return pars; } @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\"/**\") .addResourceLocations(\"classpath:/static/\"); registry.addResourceHandler(\"swagger-ui.html\") .addResourceLocations(\"classpath:/META-INF/resources/\"); registry.addResourceHandler(\"/webjars/**\") .addResourceLocations(\"classpath:/META-INF/resources/webjars/\"); } } 拦截器配置修改后如下: @Configuration public class InterceptorConfig implements WebMvcConfigurer { @Autowired private ControllerInterceptor controllerInterceptor; @Autowired private AuthBusinessInterceptor authBusinessInterceptor; @Autowired private AuthPlatformInterceptor authPlatformInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(controllerInterceptor); registry.addInterceptor(authBusinessInterceptor); registry.addInterceptor(authPlatformInterceptor) .addPathPatterns(\"/**\") .excludePathPatterns(\"/swagger-resources/**\", \"/swagger-ui.html\", \"/v2/api-docs\", \"/webjars/**\"); } } 注意：.excludePathPatterns(&quot;/swagger-resources/**&quot;, &quot;/swagger-ui.html&quot;, &quot;/v2/api-docs&quot;, &quot;/webjars/**&quot;) 是为了避免swagger-ui.html被拦截。 重启项目，访问http://ip:port/swagger-ui.html正常。","tags":[{"name":"问题及解决","slug":"问题及解决","permalink":"http://www.bestliuhao.club/tags/问题及解决/"}]},{"title":"mysql分页列表使用LEFT JOIN时的优化方法","date":"2019-05-10T00:52:03.182Z","path":"数据库/mysql分页列表使用LEFT JOIN时的优化方法/","text":"mysql分页列表使用LEFT JOIN时的优化方法分页列表查询一般格式 取分页数据 1234567SELECT *FROM table1 t1LEFT JOIN table2 t2 ON t2.id = t1.idLEFT JOIN table3 t3 ON t3.id = t1.idLEFT JOIN table4 t4 ON t4.id = t1.idWHERE t1.id = 1 AND t2. ...LIMIT 0,30 取总数 123456SELECT COUNT(0)FROM table1 t1LEFT JOIN table2 t2 ON t2.id = t1.idLEFT JOIN table3 t3 ON t3.id = t1.idLEFT JOIN table4 t4 ON t4.id = t1.idWHERE t1.id = 1 AND t2. ... 缺点 LEFT JOIN消耗性能 全部LEFT JOIN后再取分页 取总数时候不必要的LEFT JOIN影响性能 优化 WHERE 条件语句用不到的LEFT JOIN的表，放到取分页后面 取总数时候不必要的LEFT JOIN不要 取分页数据 12345678910SELECT *FROM ( SELECT * FROM table1 t1 LEFT JOIN table2 t2 ON t2.id = t1.id LEFT JOIN table3 t3 ON t3.id = t1.id WHERE t1.id = 1 AND t2. ... LIMIT 0,30 )tLEFT JOIN table4 t4 ON t4.id = t1.id 取总数 12345SELECT COUNT(0)FROM table1 t1LEFT JOIN table2 t2 ON t2.id = t1.idLEFT JOIN table2 t3 ON t3.id = t1.idWHERE t1.id = 1 AND t2. ... 具体实际应用网站分页列表优化前 数据量：9741 每页显示30条数据 平均每页刷新耗时：1100ms 列表数据12345678910111213141516171819202122232425262728293031SELECT w.*, d.`name` AS deptName, IFNULL(de.`name`,&apos;&apos;) AS superviseName, CASE WHEN w.school_id IS NULL THEN d.`name` ELSE s.name END AS schoolName FROM website w LEFT JOIN sys_dept d ON d.id = w.dept_id LEFT JOIN sys_dept de ON de.id = w.supervise_id LEFT JOIN sys_dept scan ON scan.id = w.scan_id LEFT JOIN sys_dept verify ON verify.id = w.verify_id LEFT JOIN sys_dept_info i ON i.dept_id = w.dept_id LEFT JOIN dictionary_item item ON i.area_id = item.id LEFT JOIN school s ON s.id = w.school_id WHERE w.is_del = 0 &lt;if test=&quot;deptId != null and deptId != &apos;&apos;&quot;&gt; AND d.id = #&#123;deptId&#125; &lt;/if&gt; &lt;if test=&quot;name != null and name != &apos;&apos;&quot;&gt; AND (UPPER(w.name) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;name&#125;,&apos;%&apos;))) OR UPPER(w.py) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;name&#125;,&apos;%&apos;)))) &lt;/if&gt; &lt;if test=&quot;url != null and url != &apos;&apos;&quot;&gt; AND UPPER(w.url) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;url&#125;,&apos;%&apos;))) &lt;/if&gt; &lt;if test=&quot;linkman != null and linkman != &apos;&apos;&quot;&gt; AND UPPER(w.contact_name) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;linkman&#125;,&apos;%&apos;))) &lt;/if&gt; ORDER BY w.create_date DESC &lt;if test=&quot;pageSize != null &quot;&gt; LIMIT #&#123;offset&#125;, #&#123;pageSize&#125; &lt;/if&gt; 网站数量123456789101112131415161718192021222324SELECT COUNT(0) FROM website w LEFT JOIN sys_dept d ON d.id = w.dept_id LEFT JOIN sys_dept de ON de.id = w.supervise_id LEFT JOIN sys_dept scan ON scan.id = w.scan_id LEFT JOIN sys_dept verify ON verify.id = w.verify_id LEFT JOIN sys_dept_info i ON i.dept_id = w.dept_id LEFT JOIN dictionary_item item ON i.area_id = item.id LEFT JOIN school s ON s.id = w.school_id WHERE w.is_del = 0 &lt;if test=&quot;deptId != null and deptId != &apos;&apos;&quot;&gt; AND d.id = #&#123;deptId&#125; &lt;/if&gt; &lt;if test=&quot;name != null and name != &apos;&apos;&quot;&gt; AND (UPPER(w.name) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;name&#125;,&apos;%&apos;))) OR UPPER(w.py) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;name&#125;,&apos;%&apos;)))) &lt;/if&gt; &lt;if test=&quot;url != null and url != &apos;&apos;&quot;&gt; AND UPPER(w.url) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;url&#125;,&apos;%&apos;))) &lt;/if&gt; &lt;if test=&quot;linkman != null and linkman != &apos;&apos;&quot;&gt; AND UPPER(w.contact_name) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;linkman&#125;,&apos;%&apos;))) &lt;/if&gt; 优化 数据量：9741 每页显示300条数据 平均每页刷新耗时：120ms 每页显示30条数据 平均每页刷新耗时：50ms 列表数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849SELECT t.*, item.name AS areaName, IFNULL(scan.`name`, &apos;&apos;) AS scanName, IFNULL(verify.`name`, &apos;&apos;) AS verifyName, de.`name` AS superviseName FROM ( SELECT w.id, w.name, w.url, w.dept_id, w.scan_id, w.supervise_id, w.verify_id, CASE WHEN w.school_id IS NULL THEN d.`name` ELSE s.name END AS schoolName, d.`name` AS deptName FROM website w LEFT JOIN sys_dept d ON d.id = w.dept_id LEFT JOIN school s ON s.id = w.school_id WHERE w.is_del = 0 &lt;if test=&quot;deptId != null and deptId != &apos;&apos;&quot;&gt; AND d.id = #&#123;deptId&#125; &lt;/if&gt; &lt;if test=&quot;deptName != null and deptName != &apos;&apos;&quot;&gt; AND (UPPER(d.name) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;deptName&#125;,&apos;%&apos;))) OR UPPER(d.py) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;deptName&#125;,&apos;%&apos;))) OR UPPER(s.name) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;deptName&#125;,&apos;%&apos;)))) &lt;/if&gt; &lt;if test=&quot;name != null and name != &apos;&apos;&quot;&gt; AND (UPPER(w.name) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;name&#125;,&apos;%&apos;))) OR UPPER(w.py) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;name&#125;,&apos;%&apos;)))) &lt;/if&gt; &lt;if test=&quot;url != null and url != &apos;&apos;&quot;&gt; AND UPPER(w.url) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;url&#125;,&apos;%&apos;))) &lt;/if&gt; &lt;if test=&quot;linkman != null and linkman != &apos;&apos;&quot;&gt; AND UPPER(w.contact_name) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;linkman&#125;,&apos;%&apos;))) &lt;/if&gt; ORDER BY w.create_date DESC &lt;if test=&quot;pageSize != null &quot;&gt; LIMIT #&#123;offset&#125;, #&#123;pageSize&#125; &lt;/if&gt; ) t LEFT JOIN sys_dept_info i ON i.dept_id = t.dept_id LEFT JOIN dictionary_item item ON i.area_id = item.id LEFT JOIN sys_dept de ON de.id = t.supervise_id LEFT JOIN sys_dept scan ON scan.id = t.scan_id LEFT JOIN sys_dept verify ON verify.id = t.verify_id 网站数量12345678910111213141516171819202122232425262728293031323334353637383940SELECT COUNT(0) FROM ( SELECT w.id, w.name, w.url, w.dept_id, w.scan_id, w.supervise_id, w.verify_id, CASE WHEN w.school_id IS NULL THEN d.`name` ELSE s.name END AS schoolName, d.`name` AS deptName FROM website w LEFT JOIN sys_dept d ON d.id = w.dept_id LEFT JOIN school s ON s.id = w.school_id WHERE w.is_del = 0 &lt;if test=&quot;deptId != null and deptId != &apos;&apos;&quot;&gt; AND d.id = #&#123;deptId&#125; &lt;/if&gt; &lt;if test=&quot;deptName != null and deptName != &apos;&apos;&quot;&gt; AND (UPPER(d.name) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;deptName&#125;,&apos;%&apos;))) OR UPPER(d.py) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;deptName&#125;,&apos;%&apos;))) OR UPPER(s.name) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;deptName&#125;,&apos;%&apos;)))) &lt;/if&gt; &lt;if test=&quot;name != null and name != &apos;&apos;&quot;&gt; AND (UPPER(w.name) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;name&#125;,&apos;%&apos;))) OR UPPER(w.py) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;name&#125;,&apos;%&apos;)))) &lt;/if&gt; &lt;if test=&quot;url != null and url != &apos;&apos;&quot;&gt; AND UPPER(w.url) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;url&#125;,&apos;%&apos;))) &lt;/if&gt; &lt;if test=&quot;linkman != null and linkman != &apos;&apos;&quot;&gt; AND UPPER(w.contact_name) LIKE UPPER(CONCAT(&apos;%&apos;,CONCAT(#&#123;linkman&#125;,&apos;%&apos;))) &lt;/if&gt; ORDER BY w.create_date DESC &lt;if test=&quot;pageSize != null &quot;&gt; LIMIT #&#123;offset&#125;, #&#123;pageSize&#125; &lt;/if&gt; ) t","tags":[{"name":"mysql分页列表优化","slug":"mysql分页列表优化","permalink":"http://www.bestliuhao.club/tags/mysql分页列表优化/"}]},{"title":"Hello World","date":"2019-05-10T00:52:02.857Z","path":"uncategorized/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"Java-常用查找算法","date":"2019-02-28T08:25:07.000Z","path":"Java总结/Java-常用查找算法/","text":"二叉树： 左子树上的所有节点值均小于根节点值， 右子树上的所有节点值均不小于根节点值， 左右子树也满足上述两个条件。插入过程如下图：比较4与7，4&lt;7，再比较4与7的左子树6，4&lt;6，比较4与6的左子树3，4&gt;3，比较4与3的右子树，为空，插入4。（字符串作为key比较可以用compareTo） 删除分为三种情况： p为叶子节点，直接删除该节点，再修改其父节点的指针（注意是父节点和不是根节点），如图a。 p为单支节点（即只有左子树或右子树）。让p的子树与p的父亲节点相连，删除p即可；（注意分是根节点和不是根节点）；如图b。 p的左子树和右子树均不空。找到p的后继y，因为y一定没有左子树，所以可以删除y，并让y的父亲节点成为y的右子树的父亲节点，并用y的值代替p的值；或者方法二是找到p的前驱x，x一定没有右子树，所以可以删除x，并让x的父亲节点成为y的左子树的父亲节点。如图c。 红黑树： 每个节点颜色不是黑色，就是红色 根节点是黑色的 如果节点是红色的，则它的子节点必须是黑色的（反之不一定，没有连续的红节点） 从根节点到叶子节点的每条路径，必须包含相同数目的黑色节点 红黑树继承二叉树的性质插入节点：往一个空的红黑树中，依次插入数据：12 1 9 2 0 11 7 19 4 删除节点同插入分析方式。通过任意一条从根到叶子简单路径上颜色的约束，红黑树保证最长路径不超过最短路径的二倍，因而近似平衡。 b树：B树的性质（m阶的B树，m表示节点的最大子节点数就是最大分支数，与高度h没有关系） 树中每个结点最多含有m个孩子（m&gt;=2）； 除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）；3、根结点至少有2个孩子（除非B树只包含一个结点：根结点）； 所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部结点或查询失败的结点，指向这些结点的指针都为null)；（注：叶子节点只是没有孩子和指向孩子的指针，这些节点也存在，也有元素。类似红黑树中，每一个NULL指针即当做叶子结点，只是没画出来而已，2、3规则决定是平衡树）。 每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，……，Kn，Pn)。其中： Ki (i=1…n)为关键字，且关键字按顺序升序排序K(i-1)&lt; Ki。 Pi为指向子树根的结点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。 关键字的个数n必须满足： [ceil(m / 2)-1]&lt;= n &lt;= m-1。比如有j个孩子的非叶结点恰好有j-1个关键码。 B树拆分原则： 达到最大关键字数时，中位上移，如5阶B树，1234插入下一个5，这时候为12345，违反关键字n&lt;=（5-1），这时候3上移 b+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点 中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中 hash： 倒排： 总结： 二叉树不是平衡树，让插入的值分别为1，2，3，4，5时，他会在右子树一条线上，这样跟链表是类似了，达不到高效查找的效果了 B树是一种多叉平衡查找树，红黑树是二叉平衡查找树结构，B树由于是多叉结构，对于元素数量非常多的情况下，树的深度不会像二叉结构那么大，可以保证查询效率。 b树每个节点都存储[ceil(m / 2)-1]&lt;= n &lt;= m-1个关键字，而b+树所有关键字都在叶子节点，非叶子节点作为叶子节点的索引，关键字都按从小到大顺序排列 B+树还有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持。这是数据库选用B+树的最主要原因 参考文献：常用算法：https://blog.csdn.net/eson_15/article/details/51138663 二叉树https://blog.csdn.net/u014182411/article/details/69831492 二叉树https://www.cnblogs.com/aiyelinglong/archive/2012/03/27/2419972.html 二叉树https://blog.csdn.net/eson_15/article/details/51144079 红黑树https://www.jianshu.com/p/d25e490e2441 红黑树 +1https://blog.csdn.net/tanrui519521/article/details/80980135 红黑树https://www.jianshu.com/p/7dedb7ebe033 B树https://www.jianshu.com/p/6f68d3c118d6 b+树https://www.jianshu.com/p/db226e0196b4 b树、B+树https://www.cnblogs.com/boothsun/p/8970952.html 二叉、b、b+树https://www.cnblogs.com/dreamroute/p/8484457.html 倒排索引https://blog.csdn.net/CrankZ/article/details/80615789 倒排索引","tags":[{"name":"Java总结","slug":"Java总结","permalink":"http://www.bestliuhao.club/tags/Java总结/"}]},{"title":"Java-Mysql索引原理","date":"2019-02-28T08:19:26.000Z","path":"Java总结/Java-Mysql索引原理/","text":"为了快速查询，很多时候，我们会建立不同的索引，满足需求，mysql主要索引引擎有MyISAM和InnoDB，两者都是使用B+Tree作为索引结构，两者的区别： 一是主索引的区别，InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。 二是辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。查询过程如下：在上图中，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据（h高度会影响数据量），如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。性能优化点： 索引建立 sql中使用函数会导致索引失效 sql中like “xx%”索引生效，like “%xx”和like “%xx%”，索引不生效 in (1，2，3) 常量索引生效，in (子查询)，索引不生效 缩小结果集查询 参考文献：https://blog.csdn.net/u010842515/article/details/68929687 MyISAM和InnoDB引擎区别https://www.cnblogs.com/ssrstm/p/6806111.html","tags":[{"name":"Java总结","slug":"Java总结","permalink":"http://www.bestliuhao.club/tags/Java总结/"}]},{"title":"Java-集合原理","date":"2019-02-28T07:59:51.000Z","path":"Java总结/Java-集合原理/","text":"数组中内存是连续的，只需对 [基地址+元素大小*k] 就能找到第k个元素的地址，可以快速找到特定的值，但是想在有序数组中插入一个新的数据项，就必须首先找出新数据项插入的位置，然后将比新数据项大的数据项向后移动一位，来给新的数据项腾出空间，删除同理，这样移动很费时。显而易见，如果要做很多的插入和删除操作和删除操作，就不该选用有序数组。另一方面，链表中可以快速添加和删除某个数据项，但是在链表中查找数据项可不容易，必须从头开始访问链表的每一个数据项，直到找到该数据项为止，这个过程很慢。 HashMap在JDK1.8之前，HashMap采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低而JDK1.8中，HashMap采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间transient int size：表示当前HashMap包含的键值对数量transient int modCount：表示当前HashMap修改次数int threshold：表示当前HashMap能够承受的最多的键值对数量，一旦超过这个数量HashMap就会进行扩容threshold = loadFactor 容量，12=0.7516final float loadFactor：负载因子，用于扩容static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4(表示1，左移4位，变成10000，也就是16.)：默认的初始容量static final float DEFAULT_LOAD_FACTOR = 0.75f：默认的负载因子static final int MIN_TREEIFY_CAPACITY = 64：当哈希表中的容量大于这个值时，表中的桶才能进行树形化，否则桶内元素太多时会扩容，而不是树形化，为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLDstatic final int TREEIFY_THRESHOLD = 8：当桶中元素个数超过这个值时需要使用红黑树节点替换链表节点static final int UNTREEIFY_THRESHOLD = 6：当扩容时，桶中元素个数小于这个值就会把树形的桶元素 还原（切分）为链表结构 为什么hashMap的容量一定是2的次幂?首先hashmap构造函数，默认容量是16，如果是指定容量大小，那么最终会调用tableSizeFor(initialCapacity)方法是用来计算初始容量的,这个方法会返回一个比给定容量大的最小2的次幂的数，所以一定是2的次幂，举个例子:如果你给了9，比9大的最小2的次幂是16(2^4)；如果你给个27，比27大的最小的2的次幂是32(2^5)，为什么一定要2的次幂呢？因为key值落点的计算方式： [(n - 1) &amp; hash] ，与“取余”是等价的算法第一种方式计算出的key值落点越平均，hash冲突的可能性越小。当容量大小是2的次幂时，(%和&amp;)2种算法，hash冲突可能性是一样的，但是&amp;效率高当容量不是2的次幂时， &amp;这种算法，key值落点更平均，hash冲突可能性更小，同时&amp;效率也高 负载因子为什么会影响HashMap性能，为什么默认是0.75f因为负载因子越大则HashMap的装填程度越高，也就是能容纳更多的元素，元素多了，链表大了，所以此时索引效率就会降低。反之，负载因子越小则链表中的数据量就越稀疏，此时会对空间造成烂费，但是此时索引效率高 参考文献：https://blog.csdn.net/qq_25868207/article/details/55259978https://blog.csdn.net/u010890358/article/details/80496144 hashmap扩容https://blog.csdn.net/lizhongkaide/article/details/50595719 hashmap原理https://blog.csdn.net/qq_36178899/article/details/84333151 hashmap原理https://segmentfault.com/a/1190000012926722 hashmap原理https://segmentfault.com/a/1190000017509668 hashmap落点均匀https://blog.csdn.net/u010841296/article/details/82832166 hashmap容量大小http://www.360linker.com/sj/643.jhtml hashmap容量大小","tags":[{"name":"Java总结","slug":"Java总结","permalink":"http://www.bestliuhao.club/tags/Java总结/"}]},{"title":"Java-代理","date":"2019-02-28T07:49:58.000Z","path":"Java总结/Java-代理/","text":"Jdk动态代理(代理接口) 通过获取委托类实现的所有接口，为每个接口方法创建一个代理方法，通过ProxyGenerator.generateProxyClass动态生成代理类字节码文件并加载，反射生成代理对象，代理对象调用的时候通过自定义的InvocationHandler（super.h）调用invoke方法，在回调方法invoke中，使用反射调用原对象的方法method.invoke(target, args);动态生成的代理类关键代码Cglib动态代理(代理类) 通过继承一个委托类，通过ASM框架strategy.generate(this)动态生成代理子类字节码文件并加载，反射生成对象，调用的时候可以通过实现MethodInterceptor接口的intercept拦截方法，进行拦截， intercept方法中，前后增加处理代码，然后调用proxy.invokeSuper(obj, args); （该方法，最终调用父类方法如super.add().），如果不拦截，则默认直接调用父类方法动态生成的代理类关键代码 参考文献： https://www.cnblogs.com/MOBIN/p/5597215.html","tags":[{"name":"Java总结","slug":"Java总结","permalink":"http://www.bestliuhao.club/tags/Java总结/"}]},{"title":"Java-总结 参考文献","date":"2019-02-28T07:30:15.000Z","path":"Java总结/Java-总结-参考文献/","text":"类加载机制https://www.cnblogs.com/xdouby/p/5829423.htmlhttps://blog.csdn.net/htf2620032/article/details/79298661 springlboot类加载http://www.cnblogs.com/zheting/p/6707035.html springboothttps://blog.csdn.net/leileibest_437147623/article/details/80898878 springboot jvm原理、gc垃圾回收机制：http://www.importnew.com/23792.htmlhttps://www.cnblogs.com/aspirant/p/8662690.html jdk动态原理https://www.cnblogs.com/MOBIN/p/5597215.html java集合https://blog.csdn.net/qq_25868207/article/details/55259978https://blog.csdn.net/u010890358/article/details/80496144 hashmap扩容https://blog.csdn.net/lizhongkaide/article/details/50595719 hashmap原理https://blog.csdn.net/qq_36178899/article/details/84333151 hashmap原理https://segmentfault.com/a/1190000012926722 hashmap原理https://segmentfault.com/a/1190000017509668 hashmap落点均匀https://blog.csdn.net/u010841296/article/details/82832166 hashmap容量大小http://www.360linker.com/sj/643.jhtml hashmap容量大小 Mysql索引原理https://blog.csdn.net/u010842515/article/details/68929687 MyISAM和InnoDB引擎区别https://www.cnblogs.com/ssrstm/p/6806111.html 常用算法：https://blog.csdn.net/eson_15/article/details/51138663 二叉树https://blog.csdn.net/u014182411/article/details/69831492 二叉树https://www.cnblogs.com/aiyelinglong/archive/2012/03/27/2419972.html 二叉树https://blog.csdn.net/eson_15/article/details/51144079 红黑树https://www.jianshu.com/p/d25e490e2441 红黑树 +1https://blog.csdn.net/tanrui519521/article/details/80980135 红黑树https://www.jianshu.com/p/7dedb7ebe033 B树https://www.jianshu.com/p/6f68d3c118d6 b+树https://www.jianshu.com/p/db226e0196b4 b树、B+树https://www.cnblogs.com/boothsun/p/8970952.html 二叉、b、b+树https://www.cnblogs.com/dreamroute/p/8484457.html 倒排索引https://blog.csdn.net/CrankZ/article/details/80615789 倒排索引","tags":[{"name":"Java总结","slug":"Java总结","permalink":"http://www.bestliuhao.club/tags/Java总结/"}]},{"title":"反射","date":"2019-02-28T07:23:09.000Z","path":"Java总结/Java-反射/","text":"","tags":[{"name":"Java总结","slug":"Java总结","permalink":"http://www.bestliuhao.club/tags/Java总结/"}]},{"title":"gc垃圾回收机制","date":"2019-02-28T07:06:46.000Z","path":"Java总结/gc垃圾回收机制/","text":"判断对象是否存活一般有两种方式： 引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。 可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象 什么是根引用？ 在JAVA语言中，可作为GC ROOTS的对象包括： 虚拟机栈中引用的对象（栈帧中的本地变量表）； 方法区中类静态属性引用的属性； 方法区中常量引用的对象； 本地方法栈中JNI（Native法防）引用的对象。 GC最基础的算法有三种：标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法 标记-清除算法（Mark-Sweep） 优点：解决了循环引用的问题。 缺点： 暂停整个应用； 会产生内存碎片。 不管你这个对象是不是可达的，即是不是垃圾，都要在清楚阶段被检查一遍，非常耗时. 复制算法(Copying) 优点：不会出现碎片问题。 缺点：暂停整个应用，需要2倍的内存空间 标记-整理算法(Mark-compact) 分代收集算法 年轻代（Young区）的回收算法 (回收主要以Copying算法为主) Minor GC新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。新生代通常存活时间较短，因此基于Copying算法来进行回收，所谓Copying算法就是扫描出存活的对象，并复制到一块新的完全未使用的空间中，对应于新生代，就是在Eden和FromSpace或ToSpace之间copy。新生代采用空闲指针的方式来控制GC触发，指针保持最后一个分配的对象在新生代区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发GC。当连续分配对象时，对象会逐渐从eden到survivor，最后到旧生代 年老代（Old区）的回收算法（回收主要以Mark-Compact算法为主）Full GC指发生在老年代的 GC。旧生代与新生代不同，对象存活的时间比较长，比较稳定，因此采用标记(Mark)算法来进行回收，所谓标记就是扫描出存活的对象，然后再进行回收未被标记的对象，回收后对用空出的空间要么进行合并，要么标记出来便于下次进行分配，总之就是要减少内存碎片带来的效率损耗。Major GC 是清理永久代 Eden区域是用来存放使用new或者newInstance等方式创建的对象，默认都是存放在Eden区，除非这个对象太大，或者超过了设定的阈值-XX:PretenureSizeThresold,这样的对象会被直接分配到Old区域。 2个Survivor（幸存）区，一般称S0，S1，理论上他们是一样大的，解释一下，他们是如何工作的：在不断创建对象的过程中，Eden区会满，这时候会开始做Young G也叫Minor GC，而Young空间的第一次GC就是找出Eden区中，幸存活着的对象，然后将这些对象，放到S0，或S1区中的其中一个， 假设第一次选择了S0，它会逐步将活着的对象拷贝到S0区域，但是如果S0区域满了，剩下活着的对象只能放old区域了，接下来要做的是，将Eden区域 清空，此时时候S1区域也是空的。当第二次Eden区域满的时候，就将Eden区域中活着的对象+S0区域中活着的对象，迁移到S1中，如果S1放不下，就会将剩下的部门，放到Old区域中，只是这次对象来源区域增加了S0，最后会将Eden区+S0区域，清空第三次和第四次依次类推，始终保证S0和S1有一个是空的，用来存储临时对象，用于交换空间的目的，反反复复多次没有被淘汰的对象，将会放入old区域中，默认是15次。具体的交换过程就和上图中的信息相似 参考文献： https://www.cnblogs.com/aspirant/p/8662690.html","tags":[{"name":"Java总结","slug":"Java总结","permalink":"http://www.bestliuhao.club/tags/Java总结/"}]},{"title":"Java-JVM原理、调优","date":"2019-02-28T07:02:05.000Z","path":"Java总结/Java-JVM原理、调优/","text":"JVM内存结构由堆、栈、本地方法栈、方法区等部分组成 堆：主要有新生代空间（Young）和老年代空间（Old），其中Young空间，又被分为2个部 分和3个板块，分别是1个Egen区，和2个Survivor区 栈：线程私有，JVM为每个新创建的线程都分配一个栈，它的生命周期与线程相同。也就是说,对于一个Java程序来说，它的运行就是通过对栈的操作来完成的。每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程，该过程具有先进后出的特性。本地方法栈：用于支持native方法的执行，存储了每个native方法调用的状态 方法区：存放了jvm初始化时加载器加载的类信息、静态变量、final类型的常量、属性和方法信息。（永久代和元空间都是方法区的一种实现，区别是，永久代使用的是JVM的堆内存空间，会内存溢出，而元空间使用的是物理内存，直接受到本机的物理内存限制。 ） 程序计数器：程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器 方法区和堆是所有线程共享的内存区域；而java栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。 jconsole 使用： 参考文献： http://www.importnew.com/23792.html","tags":[{"name":"Java总结","slug":"Java总结","permalink":"http://www.bestliuhao.club/tags/Java总结/"}]},{"title":"Java-类加载机制","date":"2019-02-28T06:43:57.000Z","path":"Java总结/Java-类加载机制/","text":"JVM将类加载过程分为三个步骤：装载（Load），链接（Link）和初始化(Initialize)。链接又分为三个步骤，如下图所示: 装载：通过类加载器，查找并加载类的二进制数据 链接： 验证：确保被加载类的正确性；检查class文件是否符合JVM字节码格式的，正常情况由编译器生成的class文件肯定符合，如果不是，那需要验证通过才能下一步，安全考虑 准备：为类的静态变量分配内存，并将其初始化为默认值；如private static int a = 10在准备阶段即a=0，然后解析，再到初始化的时候才a=10 解析：把类中的符号引用转换为直接引用 初始化：为类的静态变量赋予正确的初始值，及创建对象 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个这个类的java.lang.Class对象，用来封装类在方法区类的对象 使用对象 卸载 类加载器 启动类加载器(Bootstrap ClassLoader)：负责加载 JAVA_HOME\\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类 扩展类加载器(Extension ClassLoader)：负责加载 JAVA_HOME\\lib\\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类库 应用程序类加载器(Application ClassLoader)：负责加载用户路径（classpath）上的类库 自定义类加载器 JDK中的ClassLoader通过上面可以看出findClass()的实现，直接抛出一个异常，并且方法是protected，很明显这是留给我们开发者自己去实现的，我们可以通过重写findClass方法来实现我们自己的类加载器。Springboot通过@EnableAutoConfiguration注解，会根据META-INF/spring.factories文件自动配置，通过@Configuration代理原来的xml配置类，通过@ComponentScan配置类扫描路径，反射生成ioc容器 参考文献： https://www.cnblogs.com/xdouby/p/5829423.htmlhttps://blog.csdn.net/htf2620032/article/details/79298661 springlboot类加载http://www.cnblogs.com/zheting/p/6707035.html springboothttps://blog.csdn.net/leileibest_437147623/article/details/80898878 springboot","tags":[{"name":"Java总结","slug":"Java总结","permalink":"http://www.bestliuhao.club/tags/Java总结/"}]},{"title":"Java-数据类型","date":"2019-02-28T06:25:26.000Z","path":"Java总结/Java-数据类型/","text":"类型 位数 字节数 取值范围 byte 8 1 -2^7 ~ 2^7-1 short 16 2 -2^15 ~ 2^15-1 int 32 4 -2^31 ~ 2^31-1 long 64 8 -2^63 ~ 2^63-1 float 32 4 2^-149 ~ 2^128-1 double 64 8 2^-1074 ~ 2^1024-1 char 16 2 0 ~ 2^16-1 boolean: 没有固定大小根据虚拟机定义 Bit(位)、byte、字节、汉字的关系 1 bit = 1 二进制数据 1 byte = 8 bit 1 字母 = 1 byte = 8 bit 1 汉字 = 2 byte = 16 bit bit：位 一个二进制数据0或1，是1bit； byte：字节存储空间的基本计量单位，如：MySQL中定义 VARCHAR(45) 即是指 45个字节；1 byte = 8 bit 一个英文字符占一个字节； 1 字母 = 1 byte = 8 bit 一个汉字占2个字节； 1 汉字 = 2 byte = 16 bit 标点符号 汉字输入状态下，默认为全角输入方式； 英文输入状态下，默认为半角输入方式； 全角输入方式下，标点符号占2字节； 半角输入方式下，标点符号占1字节；故：汉字输入状态下的字符，占2个字节 (但不排除，自己更改了默认设置)； 英文输入状态下的字符，占1个字节 (但不排除，自己更改了默认设置)；","tags":[{"name":"Java总结","slug":"Java总结","permalink":"http://www.bestliuhao.club/tags/Java总结/"}]},{"title":"Java Bean Validation完成后端数据校验","date":"2019-01-24T08:04:09.000Z","path":"Java/Java-Bean-Validation完成后端数据校验/","text":"前言 数据的校验是交互式网站一个不可或缺的功能，前端的js校验可以涵盖大部分的校验职责，如用户名唯一性，生日格式，邮箱格式校验等等常用的校验。但是为了避免用户绕过浏览器，使用http工具直接向后端请求一些违法数据，服务端的数据校验也是必要的，可以防止脏数据落到数据库中，如果数据库中出现一个非法的邮箱格式，也会让运维人员头疼不已。我在之前保险产品研发过程中，系统对数据校验要求比较严格且追求可变性及效率，曾使用drools作为规则引擎，兼任了校验的功能。而在一般的应用，可以使用本文将要介绍的validation来对数据进行校验。 JSR303/JSR-349 简述JSR303/JSR-349，Hibernate Validation，Spring Validation之间的关系。JSR303是一项标准,JSR-349是其的升级版本，添加了一些新特性，他们规定一些校验规范即校验注解，如@Null，@NotNull，@Pattern，他们位于javax.validation.constraints包下，只提供规范不提供实现。而hibernate validation是对这个规范的实践（不要将hibernate和数据库orm框架联系在一起），他提供了相应的实现，并增加了一些其他校验注解，如@Email，@Length，@Range等等，他们位于org.hibernate.validator.constraints包下。而万能的Spring为了给开发者提供便捷，对Hibernate Validation进行了二次封装，显示校验validated bean时，你可以使用Spring Validation或者Hibernate Validation，而Springvalidation另一个特性，便是其在SpringMVC模块中添加了自动校验，并将校验信息封装进了特定的类中。这无疑便捷了我们的web开发。本文主要介绍在SpringMVC中自动校验的机制。注解如下： JSR提供的校验注解： 注解 注释 @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max=, min=) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式 Hibernate Validator提供的校验注解： 注解 注释 @NotBlank(message =) 验证字符串非null，且长度必须大于0 @Email 被注释的元素必须是电子邮箱地址 @Length(min=,max=) 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range(min=,max=,message=) 被注释的元素必须在合适的范围内 代码实现添加JAR包依赖123456&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.7.Final&lt;/version&gt; &lt;!--&lt;classifier&gt;sources&lt;/classifier&gt;--&gt;&lt;/dependency&gt; 简单校验1.在pojo中指定校验规则12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.Getter;import lombok.Setter;import org.hibernate.validator.constraints.Length;import org.springframework.format.annotation.DateTimeFormat;import javax.validation.constraints.*;import java.util.Date;@ApiModel@Getter@Setterpublic class UserInfo &#123; @ApiModelProperty(value = \"姓名\") @NotEmpty(message = \"姓名不能为空！\") @Max(value = 5, message = \"姓名长度不能超过5！\") private String name; @Length(max = 10, message = \"昵称长度不能超过10！\") @ApiModelProperty(value = \"昵称\") private String nickname; @Pattern(regexp = \"[男|女]\", message = \"性别只能在男或女中选择！\") @ApiModelProperty(value = \"性别\") private String sex; @Digits(integer = 18, fraction = 28, message = \"年龄必须在18-28之间！\") @ApiModelProperty(value = \"年龄\") private Integer age; @Past(message = \"生日必须在过去的时间里！\") @ApiModelProperty(value = \"生日\") @DateTimeFormat(pattern = \"yyyy-MM-dd\") private Date birthday; @ApiModelProperty(value = \"籍贯\") private String nativePlace; @Pattern(regexp = \"^0\\\\d&#123;2,3&#125;-\\\\d&#123;7,8&#125;$\", message = \"固定电话格式不正确！\") @ApiModelProperty(value = \"固定电话\") private String telephone; @Pattern(regexp = \"^1\\\\d&#123;10&#125;$\", message = \"移动电话格式不正确！\") @ApiModelProperty(value = \"移动电话\") private String phone; @Email(message = \"邮箱格式不正确！\") @ApiModelProperty(value = \"邮箱\") private String email; @Override public String toString() &#123; return \"UserInfo&#123;\" + \"name='\" + name + '\\'' + \", nickname='\" + nickname + '\\'' + \", sex='\" + sex + '\\'' + \", age=\" + age + \", birthday=\" + birthday + \", nativePlace='\" + nativePlace + '\\'' + \", telephone='\" + telephone + '\\'' + \", phone='\" + phone + '\\'' + \", email='\" + email + '\\'' + '&#125;'; &#125;&#125; 2.controller中对其校验绑定进行使用12345678910111213141516171819202122232425262728293031import io.swagger.annotations.Api;import org.springframework.stereotype.Controller;import org.springframework.validation.BindingResult;import org.springframework.validation.FieldError;import org.springframework.validation.annotation.Validated;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import qgs.csmp.zzz.UserInfo;import qgs.framework.core.annotation.AuthPassport;import qgs.framework.core.common.BaseController;@Api(tags = \"validation校验demo\")@Controller@RequestMapping(\"/validation\")public class DemoController extends BaseController &#123; @AuthPassport(value = false) @ResponseBody @RequestMapping(method = RequestMethod.GET) public String save(@Validated UserInfo userInfo, BindingResult bindingResult) &#123; if (bindingResult.hasErrors()) &#123; StringBuilder sb = new StringBuilder(); for (FieldError fieldError : bindingResult.getFieldErrors()) &#123; sb.append(fieldError.getDefaultMessage()).append(\",\\n\"); &#125; return sb.toString(); &#125; return \"success\"; &#125;&#125; 注： 1、@Validated作用就是将pojo内的注解数据校验规则(@NotNull等)生效，如果没有该注解的声明，pojo内有注解数据校验规则也不会生效2、BindingResult对象用来获取校验失败的信息(@NotNull中的message)，与@Validated注解必须配对使用，一前一后 对BindingResult统一异常拦截 统一异常拦截后，不必每次都对controller接口增加参数BindingResult。代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.validation.BindingResult;import org.springframework.web.bind.MethodArgumentNotValidException;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import qgs.framework.util.utilty.StringUtil;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.validation.ConstraintViolation;import javax.validation.ConstraintViolationException;import java.io.IOException;import java.io.PrintWriter;import java.util.Set;@ControllerAdvicepublic class ExceptionLogInterceptor &#123; @SuppressWarnings(\"rawtypes\") @ResponseBody @ExceptionHandler(Exception.class) public void resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception e) &#123; Logger logger = LoggerFactory.getLogger(getClass()); StringBuilder errorMsg = new StringBuilder(); StringBuilder errorLog = new StringBuilder(); if (e instanceof BindingResult || e instanceof MethodArgumentNotValidException || e instanceof ConstraintViolationException) &#123; BindingResult bindingResult = null; if (e instanceof BindingResult) &#123; bindingResult = (BindingResult) e; &#125; //实体类中包含其他实体 if (e instanceof MethodArgumentNotValidException) &#123; MethodArgumentNotValidException validException = (MethodArgumentNotValidException) e; bindingResult = validException.getBindingResult(); &#125; if (bindingResult != null &amp;&amp; bindingResult.getAllErrors() != null &amp;&amp; !bindingResult.getAllErrors().isEmpty()) &#123; errorMsg = new StringBuilder(bindingResult.getAllErrors().get(0).getDefaultMessage()); &#125; if (e instanceof ConstraintViolationException) &#123; Set&lt;ConstraintViolation&lt;?&gt;&gt; violations = ((ConstraintViolationException) e).getConstraintViolations(); for (ConstraintViolation&lt;?&gt; violation : violations) &#123; errorMsg.append(violation.getMessage()).append(\", \"); &#125; &#125; &#125; else &#123; errorMsg.append(StringUtil.isNullOrEmpty(e.getMessage()) ? e.toString() : e.getMessage()); errorLog.append(StringUtil.isNullOrEmpty(e.getMessage()) ? e.toString() : e.getMessage()); errorLog.append(\"\\r\\n\"); for (StackTraceElement traceElement : e.getStackTrace()) &#123; errorLog.append(traceElement.toString()); errorLog.append(\"\\r\\n\"); &#125; &#125; logger.error(errorLog.toString()); try &#123; response.setStatus(500); response.setContentType(\"application/json; charset=utf-8\"); PrintWriter out = response.getWriter(); out.append(\"&#123;\\\"msg\\\":\\\"\").append(errorMsg.toString()).append(\"\\\"&#125;\"); out.close(); &#125; catch (IOException ignored) &#123; &#125; &#125;&#125; 注： 这里只对一处不符合规则的错误信息输出 此时，controller代码可更改为：12345678public class DemoController extends BaseController &#123; @AuthPassport(value = false) @ResponseBody @RequestMapping(method = RequestMethod.GET) public String save(@Validated UserInfo userInfo) &#123; return \"success\"; &#125;&#125; 或者12345678public class DemoController extends BaseController &#123; @AuthPassport(value = false) @ResponseBody @RequestMapping(method = RequestMethod.GET) public String save(@Valid UserInfo userInfo) &#123; return \"success\"; &#125;&#125; @Validated或者@Valid均可 分组校验1.什么是分组校验？ 校验规则是在pojo制定的，而同一个pojo可以被多个Controller使用，此时会有问题，即：不同的Controller方法对同一个pojo进行校验，此时这些校验信息是共享在这不同的Controller方法中，但是实际上每个Controller方法可能需要不同的校验，在这种情况下，就需要使用分组校验来解决这种问题，通俗的讲，一个pojo中有很多属性，controller中的方法1可能只需要校验pojo中的属性1，controller中的方法2只需要校验pojo中的属性2，但是pojo中的校验注解有很多，怎样才能使方法1只校验属性1，方法二只校验属性2呢？就需要用分组校验来解决了。 2.定义分组 1.定义空的接口12public interface ValidationGroup1 &#123;&#125; 12public interface ValidationGroup2 &#123;&#125; 2.修改pojo，注解增加参数groups123456789101112131415161718192021222324252627282930313233343536373839404142434445public class UserInfo &#123; @ApiModelProperty(value = \"姓名\") @NotEmpty(message = \"姓名不能为空！\", groups = ValidationGroup1.class) @Max(value = 5, message = \"姓名长度不能超过5！\") private String name; @Length(max = 10, message = \"昵称长度不能超过10！\", groups = ValidationGroup2.class) @ApiModelProperty(value = \"昵称\") private String nickname; @Pattern(regexp = \"[男|女]\", message = \"性别只能在男或女中选择！\") @ApiModelProperty(value = \"性别\") private String sex; @Digits(integer = 18, fraction = 28, message = \"年龄必须在18-28之间！\") @ApiModelProperty(value = \"年龄\") private Integer age; @Past(message = \"生日必须在过去的时间里！\") @ApiModelProperty(value = \"生日\") @DateTimeFormat(pattern = \"yyyy-MM-dd\") private Date birthday; @ApiModelProperty(value = \"籍贯\") private String nativePlace; @Pattern(regexp = \"^0\\\\d&#123;2,3&#125;-\\\\d&#123;7,8&#125;$\", message = \"固定电话格式不正确！\") @ApiModelProperty(value = \"固定电话\") private String telephone; @Pattern(regexp = \"^1\\\\d&#123;10&#125;$\", message = \"移动电话格式不正确！\") @ApiModelProperty(value = \"移动电话\") private String phone; @Email(message = \"邮箱格式不正确！\") @ApiModelProperty(value = \"邮箱\") private String email; @Override public String toString() &#123; return \"UserInfo&#123;\" + \"name='\" + name + '\\'' + \", nickname='\" + nickname + '\\'' + \", sex='\" + sex + '\\'' + \", age=\" + age + \", birthday=\" + birthday + \", nativePlace='\" + nativePlace + '\\'' + \", telephone='\" + telephone + '\\'' + \", phone='\" + phone + '\\'' + \", email='\" + email + '\\'' + '&#125;'; &#125;&#125; 2.修改controller12345678public class DemoController extends BaseController &#123; @AuthPassport(value = false) @ResponseBody @RequestMapping(method = RequestMethod.GET) public String save(@Validated(value = &#123;ValidationGroup1.class&#125;) UserInfo userInfo) &#123; return \"success\"; &#125;&#125; 注： 此时只能使用@Validated注解如上，只校验pojo中groups为ValidationGroup1的属性，如name有两处校验，只会校验是否为空而不会校验长度是否大于5 自定义注解校验 业务需求总是比框架提供的这些简单校验要复杂的多，我们可以自定义校验来满足我们的需求。自定义Spring Validation非常简单，主要分为两步。 1.自定义校验注解我们尝试添加一个“字符串不能包含空格”的限制。123456789101112131415161718192021222324252627282930import javax.validation.Constraint;import javax.validation.Payload;import java.lang.annotation.Documented;import java.lang.annotation.Retention;import java.lang.annotation.Target;import static java.lang.annotation.ElementType.*;import static java.lang.annotation.RetentionPolicy.RUNTIME;@Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER&#125;)@Retention(RUNTIME)@Documented@Constraint(validatedBy = &#123;CannotHaveBlankValidator.class&#125;)public @interface CannotHaveBlank &#123; String message() default \"不能包含空格\"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; //指定多个时使用 @Target(&#123;FIELD, METHOD, PARAMETER, ANNOTATION_TYPE&#125;) @Retention(RUNTIME) @Documented @interface List &#123; CannotHaveBlank[] value(); &#125;&#125; 2 编写校验类12345678910111213141516171819202122232425import javax.validation.ConstraintValidator;import javax.validation.ConstraintValidatorContext;public class CannotHaveBlankValidator implements ConstraintValidator&lt;CannotHaveBlank, String&gt; &#123; @Override public void initialize(CannotHaveBlank constraintAnnotation) &#123; &#125; @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; //null时不进行校验 if (value != null &amp;&amp; value.contains(\" \")) &#123; //获取默认提示信息 String defaultConstraintMessageTemplate = context.getDefaultConstraintMessageTemplate(); System.out.println(\"default message :\" + defaultConstraintMessageTemplate); //禁用默认提示信息 context.disableDefaultConstraintViolation(); //设置提示语 context.buildConstraintViolationWithTemplate(\"can not contains blank\").addConstraintViolation(); return false; &#125; return true; &#125;&#125; 注: 所有的验证者都需要实现ConstraintValidator接口，它的接口包含一个初始化事件方法，和一个判断是否合法的方法。ConstraintValidatorContext 这个上下文包含了认证中所有的信息，我们可以利用这个上下文实现获取默认错误提示信息，禁用错误提示信息，改写错误提示信息等操作。 基于方法校验(controller层方法中单个参数校验) 12345678910111213@Api(tags = \"validation校验demo\")@Controller@RequestMapping(\"/validation\")@Validatedpublic class DemoController extends BaseController &#123; @AuthPassport(value = false) @ResponseBody @RequestMapping(method = RequestMethod.GET) public String save(@NotNull(message = \"不能为空\") Integer id) &#123; return \"success\"; &#125;&#125; 1.为类添加@Validated注解2.校验方法的返回值和入参","tags":[{"name":"Validation完成后端数据校验","slug":"Validation完成后端数据校验","permalink":"http://www.bestliuhao.club/tags/Validation完成后端数据校验/"}]}]